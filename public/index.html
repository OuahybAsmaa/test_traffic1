<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Carte des Itinéraires avec Congestion</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.css" />
    <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Poppins', sans-serif;
            overflow: hidden;
            background: #f0f2f5;
            transition: background 0.5s ease;
        }

        body.dark-mode {
            background: #1a1a1a;
        }

        body.dark-mode #controls,
        body.dark-mode #routes-list,
        body.dark-mode #legend,
        body.dark-mode #route-details,
        body.dark-mode #weather-panel,
        body.dark-mode #progress-bar {
            background: rgba(40, 40, 40, 0.95);
            color: #e0e0e0;
        }

        body.dark-mode #routes-list p,
        body.dark-mode #route-details p {
            background: #333;
            color: #e0e0e0;
        }

        body.dark-mode #routes-list p:hover,
        body.dark-mode #route-details p:hover {
            background: #444;
        }

        #map {
            height: 100vh;
            width: 100vw;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
            transition: filter 0.3s ease, transform 0.5s ease;
        }

        #map.night-mode {
            filter: brightness(0.5) contrast(1.2) saturate(0.8);
        }

        #map.view-3d {
            transform: perspective(800px) rotateX(20deg);
        }

        #map.rain-mode {
            filter: opacity(0.9) blur(1px);
            background: url('https://i.gifer.com/origin/3f/3f3e4a8e4a0e4a0e4a0e4a0e4a0e4a0e.gif') repeat;
            background-size: 100px;
        }

        #map.fog-mode {
            filter: opacity(0.8) brightness(0.7);
        }

        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
            width: 300px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            transition: all 0.3s ease;
        }

        #controls:hover {
            transform: scale(1.02);
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
            position: relative;
        }

        .control-group label {
            font-weight: 600;
            color: #1e3c72;
            font-size: 14px;
            display: none;
        }

        select {
            padding: 12px 40px 12px 40px;
            border: 2px solid #e0e6ed;
            border-radius: 10px;
            background: #fff;
            font-size: 14px;
            color: #333;
            cursor: pointer;
            transition: border-color 0.3s, box-shadow 0.3s;
            width: 100%;
            appearance: none;
        }

        select:hover, select:focus {
            border-color: #2a5298;
            box-shadow: 0 0 5px rgba(42, 82, 152, 0.3);
            outline: none;
        }

        .control-group::before {
            font-family: "Font Awesome 5 Free";
            font-weight: 900;
            position: absolute;
            left: 15px;
            font-size: 16px;
            color: #2a5298;
        }

        .control-group.start::before {
            content: '\f111';
            color: #4285f4;
        }

        .control-group.end::before {
            content: '\f111';
            color: #ea4335;
        }

        .button-group {
            display: flex;
            justify-content: space-between;
            gap: 10px;
            flex-wrap: wrap;
        }

        button {
            padding: 12px 20px;
            border: none;
            border-radius: 10px;
            background: linear-gradient(135deg, #2a5298, #1e3c72);
            color: white;
            font-weight: 600;
            font-size: 14px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.3s;
            box-shadow: 0 4px 15px rgba(42, 82, 152, 0.3);
            flex: 1;
        }

        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(42, 82, 152, 0.5);
        }

        button:active {
            transform: translateY(0);
            box-shadow: 0 2px 10px rgba(42, 82, 152, 0.3);
        }

        .icon-btn {
            padding: 12px;
            flex: 0 0 50px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #routes-list {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            background: rgba(255, 255, 255, 0.97);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
            max-width: 90%;
            max-height: 250px;
            overflow-y: auto;
            transition: all 0.3s ease;
        }

        #routes-list:hover {
            transform: translateX(-50%) scale(1.02);
        }

        #routes-list p {
            margin: 10px 0;
            padding: 12px 15px;
            background: #fff;
            border-radius: 10px;
            font-size: 14px;
            color: #333;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
            display: flex;
            align-items: center;
            gap: 10px;
            transition: background 0.3s, transform 0.2s;
            cursor: pointer;
        }

        #routes-list p:hover {
            background: #f1f5f9;
            transform: translateX(5px);
        }

        #legend {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            background: rgba(255, 255, 255, 0.97);
            backdrop-filter: blur(10px);
            padding: 10px 20px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            display: flex;
            gap: 15px;
            font-size: 12px;
            color: #333;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .legend-color {
            width: 20px;
            height: 10px;
            border-radius: 3px;
        }

        #route-details {
            position: absolute;
            top: 150px;
            left: 20px;
            z-index: 10;
            background: rgba(255, 255, 255, 0.97);
            backdrop-filter: blur(10px);
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            width: 300px;
            max-height: 300px;
            overflow-y: auto;
            font-size: 14px;
            color: #333;
            transition: all 0.3s ease;
            display: none;
        }

        #route-details:hover {
            transform: scale(1.02);
        }

        #route-details p {
            margin: 5px 0;
            padding: 10px;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
        }

        #weather-panel {
            position: absolute;
            top: 20px;
            left: 350px;
            z-index: 10;
            background: rgba(255, 255, 255, 0.97);
            backdrop-filter: blur(10px);
            padding: 10px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 14px;
            color: #333;
        }

        #weather-panel i {
            font-size: 20px;
        }

        #progress-bar {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 10;
            background: rgba(255, 255, 255, 0.97);
            backdrop-filter: blur(10px);
            padding: 10px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            width: 200px;
            font-size: 14px;
            color: #333;
            display: none;
        }

        #progress-bar .progress {
            height: 10px;
            background: #e0e6ed;
            border-radius: 5px;
            overflow: hidden;
        }

        #progress-bar .progress-fill {
            height: 100%;
            background: #2a5298;
            width: 0%;
            transition: width 0.3s ease;
        }

        #extra-controls {
            position: absolute;
            top: 150px;
            right: 20px;
            z-index: 10;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        #direction-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            z-index: 10;
            font-size: 30px;
            color: #2a5298;
            transform: translate(-50%, -50%) rotate(0deg);
            transition: transform 0.3s ease;
            display: none;
        }

        @media (max-width: 768px) {
            #controls, #route-details {
                width: 80%;
                left: 10px;
                top: 10px;
            }

            #routes-list {
                width: 90%;
                max-height: 150px;
                bottom: 60px;
            }

            #legend {
                flex-direction: column;
                gap: 5px;
                padding: 10px;
            }

            #weather-panel {
                left: 10px;
                top: 80px;
            }

            #progress-bar {
                width: 150px;
                top: 10px;
                right: 10px;
            }

            #extra-controls {
                top: 120px;
                right: 10px;
            }

            .icon-btn {
                flex: 0 0 40px;
            }
        }

        .swal2-red .swal2-title {
            color: #ff0000 !important;
        }
        .swal2-red .swal2-content {
            color: #ff0000 !important;
        }
    </style>
</head>
<body>
    <div id="map"></div>
    <div id="controls">
        <div class="control-group start">
            <label for="start">Départ :</label>
            <select id="start" aria-label="Point de départ"></select>
        </div>
        <div class="control-group end">
            <label for="end">Arrivée :</label>
            <select id="end" aria-label="Point d'arrivée"></select>
        </div>
        <div class="button-group">
            <button onclick="generateRoute()" aria-label="Calculer l'itinéraire">Calculer l'itinéraire</button>
            <button id="start-btn" onclick="startMoving()" aria-label="Démarrer le trajet" style="display: none;">
                <i class="fas fa-play"></i> Démarrer le trajet
            </button>
            <button class="icon-btn" onclick="showRealisticMap()" aria-label="Vue satellite">
                <i class="fas fa-satellite"></i>
            </button>
            <button class="icon-btn" onclick="setDayMode()" aria-label="Mode jour">
                <i class="fas fa-sun"></i>
            </button>
            <button class="icon-btn" onclick="setNightMode()" aria-label="Mode nuit">
                <i class="fas fa-moon"></i>
            </button>
        </div>
    </div>
    <div id="routes-list"></div>
    <div id="legend">
        <div class="legend-item">
            <div class="legend-color" style="background: green;"></div>
            <span>Fluide</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: yellow;"></div>
            <span>Moyen</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: red;"></div>
            <span>Bloqué</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: blue;"></div>
            <span>Route parcourue</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: rgba(0, 128, 0, 0.5);"></div>
            <span>Itinéraire initial (moins congestionné)</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: rgba(255, 0, 0, 0.5);"></div>
            <span>Itinéraire initial (plus congestionné)</span>
        </div>
    </div>
    <div id="route-details">
        <h4>Détails de la route</h4>
        <div id="route-details-content"></div>
    </div>
    <div id="weather-panel">
        <i id="weather-icon" class="fas fa-sun"></i>
        <span id="weather-text">Soleil</span>
    </div>
    <div id="progress-bar">
        <p>Progression du trajet : <span id="progress-text">0%</span></p>
        <div class="progress">
            <div class="progress-fill" id="progress-fill"></div>
        </div>
    </div>
    <div id="extra-controls">
        <button class="icon-btn" onclick="recenterMap()" aria-label="Recentrer la carte">
            <i class="fas fa-crosshairs"></i>
        </button>
        <button class="icon-btn" onclick="toggle3DView()" aria-label="Activer/Désactiver la vue 3D">
            <i class="fas fa-cube"></i>
        </button>
        <button class="icon-btn" onclick="shareRoute()" aria-label="Partager l'itinéraire">
            <i class="fas fa-share-alt"></i>
        </button>
        <button class="icon-btn" onclick="toggleDarkMode()" aria-label="Mode sombre">
            <i class="fas fa-adjust"></i>
        </button>
        <button class="icon-btn" onclick="toggleSound()" aria-label="Activer/Désactiver le son">
            <i class="fas fa-volume-up"></i>
        </button>
        <button class="icon-btn" onclick="toggleWeather('rain')" aria-label="Simuler la pluie">
            <i class="fas fa-cloud-rain"></i>
        </button>
        <button class="icon-btn" onclick="toggleWeather('fog')" aria-label="Simuler le brouillard">
            <i class="fas fa-smog"></i>
        </button>
        <button class="icon-btn" onclick="captureScreenshot()" aria-label="Capturer l'écran">
            <i class="fas fa-camera"></i>
        </button>
        <button class="icon-btn" onclick="toggleEcoMode()" aria-label="Mode éco">
            <i class="fas fa-leaf"></i>
        </button>
        <button class="icon-btn" onclick="toggleRouteDetails()" aria-label="Afficher/Masquer les détails de la route">
            <i class="fas fa-info-circle"></i>
        </button>
        <button class="icon-btn" onclick="resetMap()" aria-label="Réinitialiser la carte">
            <i class="fas fa-undo"></i>
        </button>
    </div>
    <div id="direction-indicator">
        <i class="fas fa-arrow-up"></i>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.js"></script>
    <script>
        var map = L.map('map').setView([33.7066, -7.3944], 12);

        const dayLayer = L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
            maxZoom: 19
        });

        const nightLayer = L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
            attribution: '© <a href="https://carto.com/attributions">CARTO</a>',
            subdomains: 'abcd',
            maxZoom: 19
        });

        const realisticLayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
            attribution: 'Tiles © Esri — Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community',
            maxZoom: 19
        });

        dayLayer.addTo(map);
        let currentLayer = dayLayer;
        let isRealisticMode = false;
        let is3DView = false;
        let isDarkMode = false;
        let isSoundEnabled = true;
        let weatherMode = null;
        let totalDistance = 0;
        let startTime = null;
        let distanceTraveled = 0;
        let isEcoMode = false;
        let isRouteDetailsVisible = false;

        let trafficData = {};
        let currentRoutingControl = null;
        let routeLayer = null;
        let initialLeastCongestedLayer = L.layerGroup().addTo(map);
        let initialMostCongestedLayer = L.layerGroup().addTo(map);
        let traveledLayer = L.layerGroup().addTo(map);
        let startMarker = null;
        let endMarker = null;
        let movingMarker = null;
        let animationFrame = null;
        let routeCoordinates = [];
        let startCoords = null;
        let endCoords = null;
        let initialStartCoords = null;
        let currentRouteSegments = [];
        let currentIndex = 0;
        let traveledSegments = [];
        let routePolylines = [];
        let initialLeastCongestedPolylines = [];
        let initialMostCongestedPolylines = [];
        let notifiedCongestionIndexes = new Set();
        let spokenNotifications = new Set(); // Suivi des notifications parlées
        let leastCongestedRoute = null;
        let mostCongestedRoute = null;
        let initialLeastCongestedRoute = null;
        let initialMostCongestedRoute = null;

        const startIcon = L.divIcon({
            html: '<i class="fas fa-map-marker-alt" style="color: green; font-size: 30px;"></i>',
            iconSize: [30, 30],
            className: 'start-icon',
            iconAnchor: [15, 30]
        });

        const endIcon = L.divIcon({
            html: '<i class="fas fa-map-marker-alt" style="color: red; font-size: 30px;"></i>',
            iconSize: [30, 30],
            className: 'end-icon',
            iconAnchor: [15, 30]
        });

        const movingIcon = L.divIcon({
            html: '<i class="fas fa-car" style="color: blue; font-size: 20px;"></i>',
            iconSize: [20, 20],
            className: 'moving-icon',
            iconAnchor: [10, 10]
        });

        function speak(text, notificationId) {
            if (!isSoundEnabled || spokenNotifications.has(notificationId)) return;
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.lang = 'fr-FR';
            utterance.rate = 1;
            utterance.pitch = 1;
            utterance.onend = () => spokenNotifications.add(notificationId);
            speechSynthesis.speak(utterance);
        }

        function toggleSound() {
            isSoundEnabled = !isSoundEnabled;
            const soundIcon = document.querySelector('#extra-controls .fa-volume-up, #extra-controls .fa-volume-mute');
            soundIcon.classList.toggle('fa-volume-up');
            soundIcon.classList.toggle('fa-volume-mute');
        }

        function toggleRouteDetails() {
            isRouteDetailsVisible = !isRouteDetailsVisible;
            document.getElementById('route-details').style.display = isRouteDetailsVisible ? 'block' : 'none';
        }

        function resetMap() {
            if (routeLayer) {
                map.removeLayer(routeLayer);
                routeLayer = null;
            }
            if (initialLeastCongestedLayer) {
                initialLeastCongestedLayer.clearLayers();
                initialLeastCongestedLayer = L.layerGroup().addTo(map);
            }
            if (initialMostCongestedLayer) {
                initialMostCongestedLayer.clearLayers();
                initialMostCongestedLayer = L.layerGroup().addTo(map);
            }
            if (traveledLayer) {
                traveledLayer.clearLayers();
                traveledLayer = L.layerGroup().addTo(map);
            }
            if (startMarker) {
                map.removeLayer(startMarker);
                startMarker = null;
            }
            if (endMarker) {
                map.removeLayer(endMarker);
                endMarker = null;
            }
            if (movingMarker) {
                map.removeLayer(movingMarker);
                movingMarker = null;
            }
            if (animationFrame) {
                cancelAnimationFrame(animationFrame);
                animationFrame = null;
            }
            routePolylines = [];
            initialLeastCongestedPolylines = [];
            initialMostCongestedPolylines = [];
            traveledSegments = [];
            routeCoordinates = [];
            currentRouteSegments = [];
            trafficData.routes = [];
            leastCongestedRoute = null;
            mostCongestedRoute = null;
            initialLeastCongestedRoute = null;
            initialMostCongestedRoute = null;
            startCoords = null;
            endCoords = null;
            initialStartCoords = null;
            currentIndex = 0;
            totalDistance = 0;
            distanceTraveled = 0;
            notifiedCongestionIndexes.clear();
            spokenNotifications.clear();
            document.getElementById('routes-list').innerHTML = '';
            document.getElementById('route-details-content').innerHTML = '';
            document.getElementById('start-btn').style.display = 'none';
            document.getElementById('progress-bar').style.display = 'none';
            document.getElementById('direction-indicator').style.display = 'none';
        }

        fetch('/traffic-data')
            .then(response => response.json())
            .then(data => {
                trafficData = data;
                populateDropdowns();
                setInterval(updateTrafficDisplay, 10000);
            })
            .catch(error => {
                console.error('Erreur chargement traffic-data.json:', error);
                trafficData = {
                    locations: {
                        "Point A": { lat: 33.7066, lng: -7.3944 },
                        "Point B": { lat: 33.7166, lng: -7.4044 }
                    }
                };
                populateDropdowns();
                setInterval(updateTrafficDisplay, 10000);
            });

        function populateDropdowns() {
            const startSelect = document.getElementById('start');
            const endSelect = document.getElementById('end');
            Object.keys(trafficData.locations).forEach(location => {
                startSelect.innerHTML += `<option value="${location}">${location}</option>`;
                endSelect.innerHTML += `<option value="${location}">${location}</option>`;
            });
        }

        function showRealisticMap() {
            if (currentLayer !== realisticLayer) {
                map.removeLayer(currentLayer);
                realisticLayer.addTo(map);
                currentLayer = realisticLayer;
                isRealisticMode = true;
                map.invalidateSize();
                document.getElementById('map').classList.remove('night-mode');
            }
        }

        function setDayMode() {
            if (isRealisticMode) {
                document.getElementById('map').classList.remove('night-mode');
            } else {
                if (currentLayer !== dayLayer) {
                    map.removeLayer(currentLayer);
                    dayLayer.addTo(map);
                    currentLayer = dayLayer;
                    map.invalidateSize();
                }
            }
        }

        function setNightMode() {
            if (isRealisticMode) {
                document.getElementById('map').classList.add('night-mode');
            } else {
                if (currentLayer !== nightLayer) {
                    map.removeLayer(currentLayer);
                    nightLayer.addTo(map);
                    currentLayer = nightLayer;
                    map.invalidateSize();
                }
            }
        }

        function toggle3DView() {
            is3DView = !is3DView;
            const mapDiv = document.getElementById('map');
            if (is3DView) {
                mapDiv.classList.add('view-3d');
            } else {
                mapDiv.classList.remove('view-3d');
            }
            map.invalidateSize();
        }

        function toggleDarkMode() {
            isDarkMode = !isDarkMode;
            document.body.classList.toggle('dark-mode');
        }

        function toggleWeather(mode) {
            const mapDiv = document.getElementById('map');
            const weatherIcon = document.getElementById('weather-icon');
            const weatherText = document.getElementById('weather-text');
            if (weatherMode === mode) {
                weatherMode = null;
                mapDiv.classList.remove('rain-mode', 'fog-mode');
                weatherIcon.className = 'fas fa-sun';
                weatherText.textContent = 'Soleil';
            } else {
                weatherMode = mode;
                mapDiv.classList.remove('rain-mode', 'fog-mode');
                if (mode === 'rain') {
                    mapDiv.classList.add('rain-mode');
                    weatherIcon.className = 'fas fa-cloud-rain';
                    weatherText.textContent = 'Pluie';
                } else if (mode === 'fog') {
                    mapDiv.classList.add('fog-mode');
                    weatherIcon.className = 'fas fa-smog';
                    weatherText.textContent = 'Brouillard';
                }
            }
        }

        function toggleEcoMode() {
            isEcoMode = !isEcoMode;
            if (isEcoMode && routeCoordinates.length > 0) {
                generateRoute(startCoords);
            }
        }

        function captureScreenshot() {
            html2canvas(document.getElementById('map')).then(canvas => {
                const link = document.createElement('a');
                link.download = 'carte-itineraire.png';
                link.href = canvas.toDataURL();
                link.click();
            });
        }

        function recenterMap() {
            const bounds = L.latLngBounds();
            if (routeLayer) {
                bounds.extend(routeLayer.getBounds());
            }
            if (initialLeastCongestedLayer) {
                bounds.extend(initialLeastCongestedLayer.getBounds());
            }
            if (initialMostCongestedLayer) {
                bounds.extend(initialMostCongestedLayer.getBounds());
            }
            if (bounds.isValid()) {
                map.fitBounds(bounds);
            }
        }

        function shareRoute() {
            const shareLink = "https://example.com/route?start=PointA&end=PointB";
            navigator.clipboard.writeText(shareLink).then(() => {
                const message = "Le lien de l'itinéraire a été copié dans le presse-papiers.";
                Swal.fire({
                    icon: 'success',
                    title: 'Lien copié !',
                    text: message,
                    position: 'top-end',
                    timer: 1500,
                    showConfirmButton: false,
                    toast: true,
                    didOpen: () => {
                        speak(message, 'share-route');
                    }
                });
            });
        }

        function calculateBearing(lat1, lon1, lat2, lon2) {
            const dLon = (lon2 - lon1) * Math.PI / 180;
            lat1 = lat1 * Math.PI / 180;
            lat2 = lat2 * Math.PI / 180;
            const y = Math.sin(dLon) * Math.cos(lat2);
            const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);
            let bearing = Math.atan2(y, x) * 180 / Math.PI;
            bearing = (bearing + 360) % 360;
            return bearing;
        }

        function findClosestIndex(newCoordinates, currentLat, currentLng) {
            let minDistance = Infinity;
            let closestIndex = 0;
            newCoordinates.forEach((coord, index) => {
                const distance = calculateDistance(currentLat, currentLng, coord[0], coord[1]);
                if (distance < minDistance) {
                    minDistance = distance;
                    closestIndex = index;
                }
            });
            return closestIndex;
        }

        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371;
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                    Math.sin(dLon / 2) * Math.sin(dLon / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return R * c;
        }

        async function generateRoute(newStartCoords = null) {
            if (!newStartCoords) {
                resetMap();
            } else {
                if (routeLayer) {
                    map.removeLayer(routeLayer);
                    routeLayer = null;
                }
                if (movingMarker) {
                    map.removeLayer(movingMarker);
                    movingMarker = null;
                }
                routePolylines = [];
                trafficData.routes = [];
            }

            if (currentRoutingControl) {
                map.removeControl(currentRoutingControl);
            }

            const startName = newStartCoords ? "Current Position" : document.getElementById('start').value;
            const endName = document.getElementById('end').value;

            if (!newStartCoords) {
                startCoords = trafficData.locations[startName];
                endCoords = trafficData.locations[endName];
                initialStartCoords = { lat: startCoords.lat, lng: startCoords.lng };
            } else {
                startCoords = newStartCoords;
            }

            if (startCoords.lat === endCoords.lat && startCoords.lng === endCoords.lng) {
                const message = "Vous êtes déjà à destination !";
                Swal.fire({
                    icon: 'info',
                    title: 'Destination atteinte',
                    text: message,
                    position: 'top-end',
                    timer: 1500,
                    showConfirmButton: false,
                    toast: true,
                    didOpen: () => {
                        speak(message, 'destination-reached');
                    }
                });
                document.getElementById('start-btn').style.display = 'none';
                return;
            }

            currentRoutingControl = L.Routing.control({
                waypoints: [
                    L.latLng(startCoords.lat, startCoords.lng),
                    L.latLng(endCoords.lat, endCoords.lng)
                ],
                routeWhileDragging: false,
                createMarker: () => null,
                lineOptions: { styles: [] },
                router: L.Routing.osrmv1({
                    serviceUrl: 'https://router.project-osrm.org/route/v1',
                    profile: 'driving'
                }),
                showAlternatives: true
            }).addTo(map);

            await new Promise((resolve) => {
                currentRoutingControl.on('routesfound', function(e) {
                    const routes = e.routes;
                    const routesList = document.getElementById('routes-list');
                    if (!newStartCoords) {
                        routesList.innerHTML = '';
                        trafficData.routes = [];
                    }
                    routeCoordinates = [];
                    currentRouteSegments = [];
                    routePolylines = [];

                    let allRoutes = [];
                    let minAvgOccupancy = Infinity;
                    let maxAvgOccupancy = -Infinity;

                    routes.forEach((route, index) => {
                        const routeDetails = route;
                        const routeId = `${startName} - ${endName}-${index + 1}`;
                        const totalDistance = routeDetails.summary.totalDistance / 1000;

                        const segments = [];
                        const coords = routeDetails.coordinates;
                        let previousTrafficStatus = 'Fluide';
                        let previousOccupancyRate = 50;

                        for (let i = 0; i < coords.length - 1; i++) {
                            const segmentDistance = calculateDistance(coords[i].lat, coords[i].lng, coords[i + 1].lat, coords[i + 1].lng);
                            const bearing = calculateBearing(coords[i].lat, coords[i].lng, coords[i + 1].lat, coords[i + 1].lng);

                            const trafficConditions = {
                                traffic_lights: Math.floor(Math.random() * 3),
                                intersections: Math.floor(Math.random() * 2),
                                road_work: Math.random() < 0.1,
                                accidents: Math.random() < 0.05
                            };

                            let trafficImpact = 0;
                            trafficImpact += trafficConditions.traffic_lights * 2;
                            trafficImpact += trafficConditions.intersections * 5;
                            if (trafficConditions.road_work) trafficImpact += 10;
                            if (trafficConditions.accidents) trafficImpact += 15;

                            const maxChange = 15;
                            let newOccupancyRate;

                            const willDegrade = Math.random() < 0.5;

                            if (willDegrade) {
                                if (previousTrafficStatus === 'Fluide') {
                                    newOccupancyRate = Math.min(100, previousOccupancyRate + (Math.random() * maxChange) + trafficImpact);
                                } else if (previousTrafficStatus === 'Moyen') {
                                    newOccupancyRate = Math.min(150, previousOccupancyRate + (Math.random() * maxChange) + trafficImpact);
                                } else {
                                    newOccupancyRate = Math.max(60, previousOccupancyRate + ((Math.random() - 0.5) * maxChange) + trafficImpact);
                                }
                            } else {
                                if (previousTrafficStatus === 'Bloqué') {
                                    newOccupancyRate = Math.max(60, previousOccupancyRate - (Math.random() * maxChange));
                                } else if (previousTrafficStatus === 'Moyen') {
                                    newOccupancyRate = Math.max(0, previousOccupancyRate - (Math.random() * maxChange));
                                } else {
                                    newOccupancyRate = Math.min(100, previousOccupancyRate + ((Math.random() - 0.5) * maxChange));
                                }
                            }

                            newOccupancyRate = Math.max(0, Math.min(150, newOccupancyRate));

                            const capacity = 600 * 2;
                            const vehicles = Math.floor((newOccupancyRate / 100) * capacity);

                            segments.push({
                                id: `${i + 1}`,
                                start: { lat: coords[i].lat, lng: coords[i].lng },
                                end: { lat: coords[i + 1].lat, lng: coords[i + 1].lng },
                                distance_km: segmentDistance,
                                bearing: bearing,
                                lanes: 2,
                                capacity_per_lane: 600,
                                vehicles: vehicles,
                                traffic_conditions: trafficConditions
                            });

                            previousOccupancyRate = newOccupancyRate;
                            const tempCapacity = 600 * 2;
                            const tempOccupancyRate = (vehicles / tempCapacity) * 100;
                            previousTrafficStatus = tempOccupancyRate < 60 ? 'Fluide' :
                                                    tempOccupancyRate <= 100 ? 'Moyen' :
                                                    'Bloqué';
                        }

                        segments.forEach(segment => {
                            const capacity = segment.capacity_per_lane * segment.lanes;
                            const occupancyRate = (segment.vehicles / capacity) * 100;
                            segment.occupancy_rate = occupancyRate.toFixed(2);
                            segment.traffic_status = occupancyRate < 60 ? 'Fluide' :
                                                    occupancyRate <= 100 ? 'Moyen' :
                                                    'Bloqué';
                        });

                        const subRoutes = [];
                        let currentRoute = { segments: [segments[0]], distance_km: segments[0].distance_km };
                        const directionThreshold = 45;
                        const minRouteDistance = 0.1;

                        for (let i = 1; i < segments.length; i++) {
                            const prevSegment = segments[i - 1];
                            const currentSegment = segments[i];
                            const directionDiff = Math.abs(currentSegment.bearing - prevSegment.bearing);

                            if (directionDiff <= directionThreshold || currentRoute.distance_km < minRouteDistance) {
                                currentRoute.segments.push(currentSegment);
                                currentRoute.distance_km += currentSegment.distance_km;
                            } else {
                                subRoutes.push(currentRoute);
                                currentRoute = { segments: [currentSegment], distance_km: currentSegment.distance_km };
                            }
                        }
                        subRoutes.push(currentRoute);

                        subRoutes.forEach((route, idx) => {
                            const totalOccupancy = route.segments.reduce((sum, seg) => sum + parseFloat(seg.occupancy_rate), 0);
                            const avgOccupancy = totalOccupancy / route.segments.length;
                            route.id = `Route ${idx + 1}`;
                            route.avg_occupancy_rate = avgOccupancy.toFixed(2);
                            route.traffic_status = avgOccupancy < 60 ? 'Fluide' :
                                                  avgOccupancy <= 100 ? 'Moyen' :
                                                  'Bloqué';
                        });

                        const totalAvgOccupancy = subRoutes.reduce((sum, r) => sum + parseFloat(r.avg_occupancy_rate), 0) / subRoutes.length;

                        const routeData = {
                            id: routeId,
                            start: startName,
                            end: endName,
                            distance_km: totalDistance,
                            routes: subRoutes,
                            avg_occupancy: totalAvgOccupancy.toFixed(2),
                            coordinates: route.coordinates
                        };
                        allRoutes.push(routeData);

                        let totalAvgOccupancyAdjusted = totalAvgOccupancy;
                        if (isEcoMode) {
                            totalAvgOccupancyAdjusted += totalDistance * 0.1;
                        }
                        if (totalAvgOccupancyAdjusted < minAvgOccupancy) {
                            minAvgOccupancy = totalAvgOccupancyAdjusted;
                            leastCongestedRoute = routeData;
                        }
                        if (totalAvgOccupancyAdjusted > maxAvgOccupancy) {
                            maxAvgOccupancy = totalAvgOccupancyAdjusted;
                            mostCongestedRoute = routeData;
                        }

                        if (!newStartCoords) {
                            routesList.innerHTML += `
                                <p onclick="highlightRoute(${index})">Itinéraire ${index + 1}: ${totalDistance.toFixed(2)} km 
                                (Congestion moyenne: ${totalAvgOccupancy.toFixed(2)}%)</p>
                            `;
                        }

                        const routeCoords = route.coordinates;
                        if (!startMarker && !newStartCoords) {
                            startMarker = L.marker([initialStartCoords.lat, initialStartCoords.lng], { icon: startIcon })
                                .addTo(map)
                                .bindPopup("Départ");
                        }
                        if (!endMarker) {
                            endMarker = L.marker([routeCoords[routeCoords.length - 1].lat, routeCoords[routeCoords.length - 1].lng], { icon: endIcon })
                                .addTo(map)
                                .bindPopup("Arrivée");
                        }

                        setTimeout(() => {
                            if (startMarker) startMarker.closePopup();
                            if (endMarker) endMarker.closePopup();
                        }, 5000);
                    });

                    trafficData.routes = allRoutes;
                    saveTrafficData();

                    if (!newStartCoords) {
                        initialLeastCongestedRoute = leastCongestedRoute;
                        initialMostCongestedRoute = mostCongestedRoute;
                    }

                    updateTrafficDisplay();
                    if (!newStartCoords) {
                        document.getElementById('start-btn').style.display = 'inline-block';
                    }

                    totalDistance = trafficData.routes[0].distance_km;

                    const routeDetailsContent = document.getElementById('route-details-content');
                    if (!newStartCoords) {
                        routeDetailsContent.innerHTML = '';
                        trafficData.routes[0].routes.forEach((route, idx) => {
                            route.segments.forEach(segment => {
                                routeDetailsContent.innerHTML += `
                                    <p>Segment ${segment.id}: ${segment.traffic_status} | Distance: ${segment.distance_km.toFixed(2)} km | 
                                    Feux: ${segment.traffic_conditions.traffic_lights}, Travaux: ${segment.traffic_conditions.road_work ? 'Oui' : 'Non'}, 
                                    Accidents: ${segment.traffic_conditions.accidents ? 'Oui' : 'Non'}</p>
                                `;
                            });
                        });
                    }

                    resolve();
                });
            });

            map.removeControl(currentRoutingControl);
        }

        function highlightRoute(index) {
            if (routePolylines[index]) {
                map.fitBounds(routePolylines[index].getBounds());
                routePolylines[index].openPopup();
            }
        }

        function updateTrafficDisplay() {
            fetch('/traffic-data')
                .then(response => response.json())
                .then(data => {
                    trafficData = data;

                    if (trafficData.routes.length > 0) {
                        if (routeLayer) {
                            map.removeLayer(routeLayer);
                        }
                        routeLayer = L.layerGroup().addTo(map);
                        routePolylines = [];

                        if (leastCongestedRoute) {
                            leastCongestedRoute.routes.forEach(r => {
                                const color = r.traffic_status === 'Bloqué' ? 'red' :
                                            r.traffic_status === 'Moyen' ? 'yellow' : 'green';
                                const coords = [];
                                r.segments.forEach(segment => {
                                    coords.push([segment.start.lat, segment.start.lng]);
                                    if (segment === r.segments[r.segments.length - 1]) {
                                        coords.push([segment.end.lat, segment.end.lng]);
                                    }
                                });

                                const polyline = L.polyline(coords, { 
                                    color: color,
                                    weight: 5,
                                    opacity: 0.7 
                                })
                                .bindPopup(`${r.id}: ${r.traffic_status} (Taux moyen: ${r.avg_occupancy_rate}%)`)
                                .addTo(routeLayer);
                                routePolylines.push(polyline);
                            });
                        }

                        if (initialLeastCongestedRoute) {
                            initialLeastCongestedLayer.clearLayers();
                            initialLeastCongestedPolylines = [];
                            initialLeastCongestedRoute.routes.forEach(r => {
                                const color = r.traffic_status === 'Bloqué' ? 'red' :
                                            r.traffic_status === 'Moyen' ? 'yellow' : 'green';
                                const coords = [];
                                r.segments.forEach(segment => {
                                    coords.push([segment.start.lat, segment.start.lng]);
                                    if (segment === r.segments[r.segments.length - 1]) {
                                        coords.push([segment.end.lat, segment.end.lng]);
                                    }
                                });

                                const polyline = L.polyline(coords, { 
                                    color: color,
                                    weight: 4,
                                    opacity: 0.5
                                })
                                .bindPopup(`Itinéraire initial (moins congestionné): ${r.traffic_status} (Taux moyen: ${r.avg_occupancy_rate}%)`)
                                .addTo(initialLeastCongestedLayer);
                                initialLeastCongestedPolylines.push(polyline);
                            });
                        }

                        if (initialMostCongestedRoute) {
                            initialMostCongestedLayer.clearLayers();
                            initialMostCongestedPolylines = [];
                            initialMostCongestedRoute.routes.forEach(r => {
                                const color = r.traffic_status === 'Bloqué' ? 'red' :
                                            r.traffic_status === 'Moyen' ? 'yellow' : 'green';
                                const coords = [];
                                r.segments.forEach(segment => {
                                    coords.push([segment.start.lat, segment.start.lng]);
                                    if (segment === r.segments[r.segments.length - 1]) {
                                        coords.push([segment.end.lat, segment.end.lng]);
                                    }
                                });

                                const polyline = L.polyline(coords, { 
                                    color: color,
                                    weight: 4,
                                    opacity: 0.5
                                })
                                .bindPopup(`Itinéraire initial (plus congestionné): ${r.traffic_status} (Taux moyen: ${r.avg_occupancy_rate}%)`)
                                .addTo(initialMostCongestedLayer);
                                initialMostCongestedPolylines.push(polyline);
                            });
                        }

                        traveledSegments.forEach(segment => {
                            const traveledCoords = [
                                [segment.start.lat, segment.start.lng],
                                [segment.end.lat, segment.end.lng]
                            ];
                            L.polyline(traveledCoords, {
                                color: 'blue',
                                weight: 5,
                                opacity: 1
                            }).addTo(traveledLayer);
                        });

                        const bounds = L.latLngBounds();
                        if (routeLayer) {
                            bounds.extend(routeLayer.getBounds());
                        }
                        if (initialLeastCongestedLayer) {
                            bounds.extend(initialLeastCongestedLayer.getBounds());
                        }
                        if (initialMostCongestedLayer) {
                            bounds.extend(initialMostCongestedLayer.getBounds());
                        }
                        if (bounds.isValid()) {
                            map.fitBounds(bounds);
                        }
                    }
                });
        }

        function saveTrafficData() {
            fetch('/save-traffic-data', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(trafficData)
            }).catch(error => console.error('Erreur sauvegarde:', error));
        }

        function updateProgressBar(progress) {
            document.getElementById('progress-text').textContent = `${progress.toFixed(0)}%`;
            document.getElementById('progress-fill').style.width = `${progress}%`;
        }

        function checkUpcomingCongestion(currentIdx) {
            const lookAheadDistance = 5; // Vérifie 5 segments à l'avance
            for (let i = currentIdx + 1; i < Math.min(currentIdx + lookAheadDistance, currentRouteSegments.length); i++) {
                const segment = currentRouteSegments[i];
                if (segment.traffic_status === 'Bloqué' && !notifiedCongestionIndexes.has(i)) {
                    const notificationId = `congestion-ahead-${i}`;
                    const message = "Attention, congestion détectée à venir dans quelques kilomètres. Recherche d'un meilleur itinéraire en cours.";
                    Swal.fire({
                        icon: 'warning',
                        title: 'Congestion à venir',
                        text: message,
                        position: 'top',
                        timer: 4000,
                        showConfirmButton: false,
                        toast: true,
                        customClass: 'swal2-red',
                        didOpen: () => {
                            speak(message, notificationId);
                        }
                    });
                    notifiedCongestionIndexes.add(i);
                    return true;
                }
            }
            return false;
        }

        function startMoving() {
            if (!trafficData.routes.length || !startMarker) return;

            if (movingMarker) {
                map.removeLayer(movingMarker);
                movingMarker = null;
            }

            trafficData.routes = [leastCongestedRoute];
            const routesList = document.getElementById('routes-list');
            routesList.innerHTML = `
                <p>Itinéraire optimal: ${leastCongestedRoute.distance_km.toFixed(2)} km 
                (Congestion moyenne: ${leastCongestedRoute.avg_occupancy}%)</p>
            `;
            saveTrafficData();

            routeCoordinates = [];
            currentRouteSegments = [];
            leastCongestedRoute.routes.forEach(r => {
                r.segments.forEach(segment => {
                    routeCoordinates.push([segment.start.lat, segment.start.lng]);
                    currentRouteSegments.push({
                        start: segment.start,
                        end: segment.end,
                        traffic_status: r.traffic_status,
                        bearing: segment.bearing
                    });
                    if (segment === r.segments[r.segments.length - 1]) {
                        routeCoordinates.push([segment.end.lat, segment.end.lng]);
                    }
                });
            });

            currentIndex = 0;

            updateTrafficDisplay();

            const speed = 0.00001;
            startTime = Date.now();
            totalDistance = leastCongestedRoute.distance_km;
            distanceTraveled = 0;

            movingMarker = L.marker([routeCoordinates[0][0], routeCoordinates[0][1]], { icon: movingIcon }).addTo(map);

            document.getElementById('progress-bar').style.display = 'block';
            document.getElementById('direction-indicator').style.display = 'block';
            if (isRouteDetailsVisible) {
                document.getElementById('route-details').style.display = 'block';
            }

            function animate() {
                if (currentIndex >= routeCoordinates.length - 1) {
                    updateProgressBar(100);
                    const notificationId = 'destination-reached';
                    const message = "Vous avez atteint votre destination avec succès.";
                    Swal.fire({
                        icon: 'success',
                        title: 'Arrivée !',
                        text: message,
                        position: 'top-end',
                        timer: 2000,
                        showConfirmButton: false,
                        toast: true,
                        didOpen: () => {
                            speak(message, notificationId);
                        }
                    });
                    document.getElementById('direction-indicator').style.display = 'none';
                    document.getElementById('progress-bar').style.display = 'none';
                    map.flyTo([endCoords.lat, endCoords.lng], 15, { duration: 2 });
                    updateTrafficDisplay();
                    if (movingMarker) {
                        map.removeLayer(movingMarker);
                        movingMarker = null;
                    }
                    return;
                }

                const start = routeCoordinates[currentIndex];
                const end = routeCoordinates[currentIndex + 1];
                const latDiff = end[0] - start[0];
                const lngDiff = end[1] - start[1];
                const distance = Math.sqrt(latDiff * latDiff + lngDiff * lngDiff);
                const steps = Math.max(1, Math.floor(distance / speed));
                let step = 0;

                const bearing = calculateBearing(start[0], start[1], end[0], end[1]);
                document.getElementById('direction-indicator').style.transform = `translate(-50%, -50%) rotate(${bearing}deg)`;

                const shouldReroute = checkUpcomingCongestion(currentIndex);

                const currentSegment = currentRouteSegments[currentIndex];
                if (currentSegment && currentSegment.traffic_status === 'Bloqué' && !notifiedCongestionIndexes.has(currentIndex)) {
                    const notificationId = `congestion-current-${currentIndex}`;
                    const message = "Zone congestionnée atteinte. Recherche d'un meilleur itinéraire en cours.";
                    Swal.fire({
                        icon: 'warning',
                        title: 'Congestion',
                        text: message,
                        position: 'top',
                        timer: 2000,
                        showConfirmButton: false,
                        toast: true,
                        customClass: 'swal2-red',
                        didOpen: () => {
                            speak(message, notificationId);
                        }
                    });
                    notifiedCongestionIndexes.add(currentIndex);
                }

                if (shouldReroute || (currentSegment && currentSegment.traffic_status === 'Bloqué')) {
                    cancelAnimationFrame(animationFrame);
                    const currentLat = start[0] + (latDiff * (step / steps));
                    const currentLng = start[1] + (lngDiff * (step / steps));
                    startCoords = { lat: currentLat, lng: currentLng };
                    generateRoute(startCoords).then(() => {
                        const newIndex = findClosestIndex(routeCoordinates, startCoords.lat, startCoords.lng);
                        currentIndex = newIndex;
                        startMoving();
                    });
                    return;
                }

                function moveStep() {
                    step++;
                    if (step <= steps) {
                        const progress = step / steps;
                        const newLat = start[0] + (latDiff * progress);
                        const newLng = start[1] + (lngDiff * progress);

                        if (movingMarker) {
                            movingMarker.setLatLng([newLat, newLng]);
                        }

                        const segmentDistance = calculateDistance(start[0], start[1], newLat, newLng);
                        distanceTraveled += segmentDistance;

                        const progressPercentage = (currentIndex + progress) / (routeCoordinates.length - 1) * 100;
                        updateProgressBar(progressPercentage);

                        animationFrame = requestAnimationFrame(moveStep);
                    } else {
                        traveledSegments.push({
                            start: { lat: start[0], lng: start[1] },
                            end: { lat: end[0], lng: end[1] }
                        });
                        const traveledCoords = [
                            [start[0], start[1]],
                            [end[0], end[1]]
                        ];
                        L.polyline(traveledCoords, {
                            color: 'blue',
                            weight: 5,
                            opacity: 1
                        }).addTo(traveledLayer);
                        updateTrafficDisplay();
                        currentIndex++;
                        if (currentIndex < routeCoordinates.length - 1) {
                            animationFrame = requestAnimationFrame(animate);
                        }
                    }
                }

                animationFrame = requestAnimationFrame(moveStep);
            }

            animate();
        }
    </script>
</body>
</html>